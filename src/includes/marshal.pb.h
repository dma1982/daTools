// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: marshal.proto

#ifndef PROTOBUF_marshal_2eproto__INCLUDED
#define PROTOBUF_marshal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ogl
{

// Internal implementation detail -- do not call these.
    void  protobuf_AddDesc_marshal_2eproto();
    void protobuf_AssignDesc_marshal_2eproto();
    void protobuf_ShutdownFile_marshal_2eproto();

    class JobRunnerOption;
    class JobOption;
    class TaskOption;
    class Exception;
    class CommandHeader;

// ===================================================================

    class JobRunnerOption : public ::google::protobuf::Message
    {
        public:
            JobRunnerOption();
            virtual ~JobRunnerOption();

            JobRunnerOption(const JobRunnerOption& from);

            inline JobRunnerOption& operator=(const JobRunnerOption& from)
            {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
            {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
            {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const JobRunnerOption& default_instance();

            void Swap(JobRunnerOption* other);

            // implements Message ----------------------------------------------

            JobRunnerOption* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const JobRunnerOption& from);
            void MergeFrom(const JobRunnerOption& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const
            {
                return _cached_size_;
            }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // optional string runner_id = 1;
            inline bool has_runner_id() const;
            inline void clear_runner_id();
            static const int kRunnerIdFieldNumber = 1;
            inline const ::std::string& runner_id() const;
            inline void set_runner_id(const ::std::string& value);
            inline void set_runner_id(const char* value);
            inline void set_runner_id(const char* value, size_t size);
            inline ::std::string* mutable_runner_id();
            inline ::std::string* release_runner_id();
            inline void set_allocated_runner_id(::std::string* runner_id);

            // optional string runner_mgr_id = 2;
            inline bool has_runner_mgr_id() const;
            inline void clear_runner_mgr_id();
            static const int kRunnerMgrIdFieldNumber = 2;
            inline const ::std::string& runner_mgr_id() const;
            inline void set_runner_mgr_id(const ::std::string& value);
            inline void set_runner_mgr_id(const char* value);
            inline void set_runner_mgr_id(const char* value, size_t size);
            inline ::std::string* mutable_runner_mgr_id();
            inline ::std::string* release_runner_mgr_id();
            inline void set_allocated_runner_mgr_id(::std::string* runner_mgr_id);

            // optional int64 pid = 3;
            inline bool has_pid() const;
            inline void clear_pid();
            static const int kPidFieldNumber = 3;
            inline ::google::protobuf::int64 pid() const;
            inline void set_pid(::google::protobuf::int64 value);

            // @@protoc_insertion_point(class_scope:ogl.JobRunnerOption)
        private:
            inline void set_has_runner_id();
            inline void clear_has_runner_id();
            inline void set_has_runner_mgr_id();
            inline void clear_has_runner_mgr_id();
            inline void set_has_pid();
            inline void clear_has_pid();

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            ::std::string* runner_id_;
            ::std::string* runner_mgr_id_;
            ::google::protobuf::int64 pid_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

            friend void  protobuf_AddDesc_marshal_2eproto();
            friend void protobuf_AssignDesc_marshal_2eproto();
            friend void protobuf_ShutdownFile_marshal_2eproto();

            void InitAsDefaultInstance();
            static JobRunnerOption* default_instance_;
    };
// -------------------------------------------------------------------

    class JobOption : public ::google::protobuf::Message
    {
        public:
            JobOption();
            virtual ~JobOption();

            JobOption(const JobOption& from);

            inline JobOption& operator=(const JobOption& from)
            {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
            {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
            {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const JobOption& default_instance();

            void Swap(JobOption* other);

            // implements Message ----------------------------------------------

            JobOption* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const JobOption& from);
            void MergeFrom(const JobOption& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const
            {
                return _cached_size_;
            }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // optional int64 priority = 1;
            inline bool has_priority() const;
            inline void clear_priority();
            static const int kPriorityFieldNumber = 1;
            inline ::google::protobuf::int64 priority() const;
            inline void set_priority(::google::protobuf::int64 value);

            // optional string name = 2;
            inline bool has_name() const;
            inline void clear_name();
            static const int kNameFieldNumber = 2;
            inline const ::std::string& name() const;
            inline void set_name(const ::std::string& value);
            inline void set_name(const char* value);
            inline void set_name(const char* value, size_t size);
            inline ::std::string* mutable_name();
            inline ::std::string* release_name();
            inline void set_allocated_name(::std::string* name);

            // optional string command = 3;
            inline bool has_command() const;
            inline void clear_command();
            static const int kCommandFieldNumber = 3;
            inline const ::std::string& command() const;
            inline void set_command(const ::std::string& value);
            inline void set_command(const char* value);
            inline void set_command(const char* value, size_t size);
            inline ::std::string* mutable_command();
            inline ::std::string* release_command();
            inline void set_allocated_command(::std::string* command);

            // repeated string args = 4;
            inline int args_size() const;
            inline void clear_args();
            static const int kArgsFieldNumber = 4;
            inline const ::std::string& args(int index) const;
            inline ::std::string* mutable_args(int index);
            inline void set_args(int index, const ::std::string& value);
            inline void set_args(int index, const char* value);
            inline void set_args(int index, const char* value, size_t size);
            inline ::std::string* add_args();
            inline void add_args(const ::std::string& value);
            inline void add_args(const char* value);
            inline void add_args(const char* value, size_t size);
            inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
            inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

            // repeated string environment = 5;
            inline int environment_size() const;
            inline void clear_environment();
            static const int kEnvironmentFieldNumber = 5;
            inline const ::std::string& environment(int index) const;
            inline ::std::string* mutable_environment(int index);
            inline void set_environment(int index, const ::std::string& value);
            inline void set_environment(int index, const char* value);
            inline void set_environment(int index, const char* value, size_t size);
            inline ::std::string* add_environment();
            inline void add_environment(const ::std::string& value);
            inline void add_environment(const char* value);
            inline void add_environment(const char* value, size_t size);
            inline const ::google::protobuf::RepeatedPtrField< ::std::string>& environment() const;
            inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_environment();

            // optional string work_directory = 6;
            inline bool has_work_directory() const;
            inline void clear_work_directory();
            static const int kWorkDirectoryFieldNumber = 6;
            inline const ::std::string& work_directory() const;
            inline void set_work_directory(const ::std::string& value);
            inline void set_work_directory(const char* value);
            inline void set_work_directory(const char* value, size_t size);
            inline ::std::string* mutable_work_directory();
            inline ::std::string* release_work_directory();
            inline void set_allocated_work_directory(::std::string* work_directory);

            // optional string runner_id = 7;
            inline bool has_runner_id() const;
            inline void clear_runner_id();
            static const int kRunnerIdFieldNumber = 7;
            inline const ::std::string& runner_id() const;
            inline void set_runner_id(const ::std::string& value);
            inline void set_runner_id(const char* value);
            inline void set_runner_id(const char* value, size_t size);
            inline ::std::string* mutable_runner_id();
            inline ::std::string* release_runner_id();
            inline void set_allocated_runner_id(::std::string* runner_id);

            // optional int64 job_id = 8;
            inline bool has_job_id() const;
            inline void clear_job_id();
            static const int kJobIdFieldNumber = 8;
            inline ::google::protobuf::int64 job_id() const;
            inline void set_job_id(::google::protobuf::int64 value);

            // @@protoc_insertion_point(class_scope:ogl.JobOption)
        private:
            inline void set_has_priority();
            inline void clear_has_priority();
            inline void set_has_name();
            inline void clear_has_name();
            inline void set_has_command();
            inline void clear_has_command();
            inline void set_has_work_directory();
            inline void clear_has_work_directory();
            inline void set_has_runner_id();
            inline void clear_has_runner_id();
            inline void set_has_job_id();
            inline void clear_has_job_id();

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            ::google::protobuf::int64 priority_;
            ::std::string* name_;
            ::std::string* command_;
            ::google::protobuf::RepeatedPtrField< ::std::string> args_;
            ::google::protobuf::RepeatedPtrField< ::std::string> environment_;
            ::std::string* work_directory_;
            ::std::string* runner_id_;
            ::google::protobuf::int64 job_id_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

            friend void  protobuf_AddDesc_marshal_2eproto();
            friend void protobuf_AssignDesc_marshal_2eproto();
            friend void protobuf_ShutdownFile_marshal_2eproto();

            void InitAsDefaultInstance();
            static JobOption* default_instance_;
    };
// -------------------------------------------------------------------

    class TaskOption : public ::google::protobuf::Message
    {
        public:
            TaskOption();
            virtual ~TaskOption();

            TaskOption(const TaskOption& from);

            inline TaskOption& operator=(const TaskOption& from)
            {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
            {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
            {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const TaskOption& default_instance();

            void Swap(TaskOption* other);

            // implements Message ----------------------------------------------

            TaskOption* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const TaskOption& from);
            void MergeFrom(const TaskOption& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const
            {
                return _cached_size_;
            }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // optional string task_input = 1;
            inline bool has_task_input() const;
            inline void clear_task_input();
            static const int kTaskInputFieldNumber = 1;
            inline const ::std::string& task_input() const;
            inline void set_task_input(const ::std::string& value);
            inline void set_task_input(const char* value);
            inline void set_task_input(const char* value, size_t size);
            inline ::std::string* mutable_task_input();
            inline ::std::string* release_task_input();
            inline void set_allocated_task_input(::std::string* task_input);

            // optional string task_output = 2;
            inline bool has_task_output() const;
            inline void clear_task_output();
            static const int kTaskOutputFieldNumber = 2;
            inline const ::std::string& task_output() const;
            inline void set_task_output(const ::std::string& value);
            inline void set_task_output(const char* value);
            inline void set_task_output(const char* value, size_t size);
            inline ::std::string* mutable_task_output();
            inline ::std::string* release_task_output();
            inline void set_allocated_task_output(::std::string* task_output);

            // optional int64 priority = 3;
            inline bool has_priority() const;
            inline void clear_priority();
            static const int kPriorityFieldNumber = 3;
            inline ::google::protobuf::int64 priority() const;
            inline void set_priority(::google::protobuf::int64 value);

            // optional string job_name = 4;
            inline bool has_job_name() const;
            inline void clear_job_name();
            static const int kJobNameFieldNumber = 4;
            inline const ::std::string& job_name() const;
            inline void set_job_name(const ::std::string& value);
            inline void set_job_name(const char* value);
            inline void set_job_name(const char* value, size_t size);
            inline ::std::string* mutable_job_name();
            inline ::std::string* release_job_name();
            inline void set_allocated_job_name(::std::string* job_name);

            // optional string runner_id = 5;
            inline bool has_runner_id() const;
            inline void clear_runner_id();
            static const int kRunnerIdFieldNumber = 5;
            inline const ::std::string& runner_id() const;
            inline void set_runner_id(const ::std::string& value);
            inline void set_runner_id(const char* value);
            inline void set_runner_id(const char* value, size_t size);
            inline ::std::string* mutable_runner_id();
            inline ::std::string* release_runner_id();
            inline void set_allocated_runner_id(::std::string* runner_id);

            // optional int64 job_id = 6;
            inline bool has_job_id() const;
            inline void clear_job_id();
            static const int kJobIdFieldNumber = 6;
            inline ::google::protobuf::int64 job_id() const;
            inline void set_job_id(::google::protobuf::int64 value);

            // optional int64 task_id = 7;
            inline bool has_task_id() const;
            inline void clear_task_id();
            static const int kTaskIdFieldNumber = 7;
            inline ::google::protobuf::int64 task_id() const;
            inline void set_task_id(::google::protobuf::int64 value);

            // @@protoc_insertion_point(class_scope:ogl.TaskOption)
        private:
            inline void set_has_task_input();
            inline void clear_has_task_input();
            inline void set_has_task_output();
            inline void clear_has_task_output();
            inline void set_has_priority();
            inline void clear_has_priority();
            inline void set_has_job_name();
            inline void clear_has_job_name();
            inline void set_has_runner_id();
            inline void clear_has_runner_id();
            inline void set_has_job_id();
            inline void clear_has_job_id();
            inline void set_has_task_id();
            inline void clear_has_task_id();

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            ::std::string* task_input_;
            ::std::string* task_output_;
            ::google::protobuf::int64 priority_;
            ::std::string* job_name_;
            ::std::string* runner_id_;
            ::google::protobuf::int64 job_id_;
            ::google::protobuf::int64 task_id_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

            friend void  protobuf_AddDesc_marshal_2eproto();
            friend void protobuf_AssignDesc_marshal_2eproto();
            friend void protobuf_ShutdownFile_marshal_2eproto();

            void InitAsDefaultInstance();
            static TaskOption* default_instance_;
    };
// -------------------------------------------------------------------

    class Exception : public ::google::protobuf::Message
    {
        public:
            Exception();
            virtual ~Exception();

            Exception(const Exception& from);

            inline Exception& operator=(const Exception& from)
            {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
            {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
            {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const Exception& default_instance();

            void Swap(Exception* other);

            // implements Message ----------------------------------------------

            Exception* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const Exception& from);
            void MergeFrom(const Exception& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const
            {
                return _cached_size_;
            }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // optional string message = 1;
            inline bool has_message() const;
            inline void clear_message();
            static const int kMessageFieldNumber = 1;
            inline const ::std::string& message() const;
            inline void set_message(const ::std::string& value);
            inline void set_message(const char* value);
            inline void set_message(const char* value, size_t size);
            inline ::std::string* mutable_message();
            inline ::std::string* release_message();
            inline void set_allocated_message(::std::string* message);

            // @@protoc_insertion_point(class_scope:ogl.Exception)
        private:
            inline void set_has_message();
            inline void clear_has_message();

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            ::std::string* message_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

            friend void  protobuf_AddDesc_marshal_2eproto();
            friend void protobuf_AssignDesc_marshal_2eproto();
            friend void protobuf_ShutdownFile_marshal_2eproto();

            void InitAsDefaultInstance();
            static Exception* default_instance_;
    };
// -------------------------------------------------------------------

    class CommandHeader : public ::google::protobuf::Message
    {
        public:
            CommandHeader();
            virtual ~CommandHeader();

            CommandHeader(const CommandHeader& from);

            inline CommandHeader& operator=(const CommandHeader& from)
            {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
            {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
            {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const CommandHeader& default_instance();

            void Swap(CommandHeader* other);

            // implements Message ----------------------------------------------

            CommandHeader* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const CommandHeader& from);
            void MergeFrom(const CommandHeader& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const
            {
                return _cached_size_;
            }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // optional string context_id = 1;
            inline bool has_context_id() const;
            inline void clear_context_id();
            static const int kContextIdFieldNumber = 1;
            inline const ::std::string& context_id() const;
            inline void set_context_id(const ::std::string& value);
            inline void set_context_id(const char* value);
            inline void set_context_id(const char* value, size_t size);
            inline ::std::string* mutable_context_id();
            inline ::std::string* release_context_id();
            inline void set_allocated_context_id(::std::string* context_id);

            // required int32 type = 2;
            inline bool has_type() const;
            inline void clear_type();
            static const int kTypeFieldNumber = 2;
            inline ::google::protobuf::int32 type() const;
            inline void set_type(::google::protobuf::int32 value);

            // optional int64 data_size = 3;
            inline bool has_data_size() const;
            inline void clear_data_size();
            static const int kDataSizeFieldNumber = 3;
            inline ::google::protobuf::int64 data_size() const;
            inline void set_data_size(::google::protobuf::int64 value);

            // @@protoc_insertion_point(class_scope:ogl.CommandHeader)
        private:
            inline void set_has_context_id();
            inline void clear_has_context_id();
            inline void set_has_type();
            inline void clear_has_type();
            inline void set_has_data_size();
            inline void clear_has_data_size();

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            ::std::string* context_id_;
            ::google::protobuf::int64 data_size_;
            ::google::protobuf::int32 type_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

            friend void  protobuf_AddDesc_marshal_2eproto();
            friend void protobuf_AssignDesc_marshal_2eproto();
            friend void protobuf_ShutdownFile_marshal_2eproto();

            void InitAsDefaultInstance();
            static CommandHeader* default_instance_;
    };
// ===================================================================


// ===================================================================

// JobRunnerOption

// optional string runner_id = 1;
    inline bool JobRunnerOption::has_runner_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void JobRunnerOption::set_has_runner_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void JobRunnerOption::clear_has_runner_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void JobRunnerOption::clear_runner_id()
    {
        if (runner_id_ != &::google::protobuf::internal::kEmptyString)
        {
            runner_id_->clear();
        }
        clear_has_runner_id();
    }
    inline const ::std::string& JobRunnerOption::runner_id() const
    {
        return *runner_id_;
    }
    inline void JobRunnerOption::set_runner_id(const ::std::string& value)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(value);
    }
    inline void JobRunnerOption::set_runner_id(const char* value)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(value);
    }
    inline void JobRunnerOption::set_runner_id(const char* value, size_t size)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* JobRunnerOption::mutable_runner_id()
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        return runner_id_;
    }
    inline ::std::string* JobRunnerOption::release_runner_id()
    {
        clear_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = runner_id_;
            runner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void JobRunnerOption::set_allocated_runner_id(::std::string* runner_id)
    {
        if (runner_id_ != &::google::protobuf::internal::kEmptyString)
        {
            delete runner_id_;
        }
        if (runner_id)
        {
            set_has_runner_id();
            runner_id_ = runner_id;
        }
        else
        {
            clear_has_runner_id();
            runner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional string runner_mgr_id = 2;
    inline bool JobRunnerOption::has_runner_mgr_id() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void JobRunnerOption::set_has_runner_mgr_id()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void JobRunnerOption::clear_has_runner_mgr_id()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void JobRunnerOption::clear_runner_mgr_id()
    {
        if (runner_mgr_id_ != &::google::protobuf::internal::kEmptyString)
        {
            runner_mgr_id_->clear();
        }
        clear_has_runner_mgr_id();
    }
    inline const ::std::string& JobRunnerOption::runner_mgr_id() const
    {
        return *runner_mgr_id_;
    }
    inline void JobRunnerOption::set_runner_mgr_id(const ::std::string& value)
    {
        set_has_runner_mgr_id();
        if (runner_mgr_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_mgr_id_ = new ::std::string;
        }
        runner_mgr_id_->assign(value);
    }
    inline void JobRunnerOption::set_runner_mgr_id(const char* value)
    {
        set_has_runner_mgr_id();
        if (runner_mgr_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_mgr_id_ = new ::std::string;
        }
        runner_mgr_id_->assign(value);
    }
    inline void JobRunnerOption::set_runner_mgr_id(const char* value, size_t size)
    {
        set_has_runner_mgr_id();
        if (runner_mgr_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_mgr_id_ = new ::std::string;
        }
        runner_mgr_id_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* JobRunnerOption::mutable_runner_mgr_id()
    {
        set_has_runner_mgr_id();
        if (runner_mgr_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_mgr_id_ = new ::std::string;
        }
        return runner_mgr_id_;
    }
    inline ::std::string* JobRunnerOption::release_runner_mgr_id()
    {
        clear_has_runner_mgr_id();
        if (runner_mgr_id_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = runner_mgr_id_;
            runner_mgr_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void JobRunnerOption::set_allocated_runner_mgr_id(::std::string* runner_mgr_id)
    {
        if (runner_mgr_id_ != &::google::protobuf::internal::kEmptyString)
        {
            delete runner_mgr_id_;
        }
        if (runner_mgr_id)
        {
            set_has_runner_mgr_id();
            runner_mgr_id_ = runner_mgr_id;
        }
        else
        {
            clear_has_runner_mgr_id();
            runner_mgr_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional int64 pid = 3;
    inline bool JobRunnerOption::has_pid() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void JobRunnerOption::set_has_pid()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void JobRunnerOption::clear_has_pid()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void JobRunnerOption::clear_pid()
    {
        pid_ = GOOGLE_LONGLONG(0);
        clear_has_pid();
    }
    inline ::google::protobuf::int64 JobRunnerOption::pid() const
    {
        return pid_;
    }
    inline void JobRunnerOption::set_pid(::google::protobuf::int64 value)
    {
        set_has_pid();
        pid_ = value;
    }

// -------------------------------------------------------------------

// JobOption

// optional int64 priority = 1;
    inline bool JobOption::has_priority() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void JobOption::set_has_priority()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void JobOption::clear_has_priority()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void JobOption::clear_priority()
    {
        priority_ = GOOGLE_LONGLONG(0);
        clear_has_priority();
    }
    inline ::google::protobuf::int64 JobOption::priority() const
    {
        return priority_;
    }
    inline void JobOption::set_priority(::google::protobuf::int64 value)
    {
        set_has_priority();
        priority_ = value;
    }

// optional string name = 2;
    inline bool JobOption::has_name() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void JobOption::set_has_name()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void JobOption::clear_has_name()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void JobOption::clear_name()
    {
        if (name_ != &::google::protobuf::internal::kEmptyString)
        {
            name_->clear();
        }
        clear_has_name();
    }
    inline const ::std::string& JobOption::name() const
    {
        return *name_;
    }
    inline void JobOption::set_name(const ::std::string& value)
    {
        set_has_name();
        if (name_ == &::google::protobuf::internal::kEmptyString)
        {
            name_ = new ::std::string;
        }
        name_->assign(value);
    }
    inline void JobOption::set_name(const char* value)
    {
        set_has_name();
        if (name_ == &::google::protobuf::internal::kEmptyString)
        {
            name_ = new ::std::string;
        }
        name_->assign(value);
    }
    inline void JobOption::set_name(const char* value, size_t size)
    {
        set_has_name();
        if (name_ == &::google::protobuf::internal::kEmptyString)
        {
            name_ = new ::std::string;
        }
        name_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* JobOption::mutable_name()
    {
        set_has_name();
        if (name_ == &::google::protobuf::internal::kEmptyString)
        {
            name_ = new ::std::string;
        }
        return name_;
    }
    inline ::std::string* JobOption::release_name()
    {
        clear_has_name();
        if (name_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = name_;
            name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void JobOption::set_allocated_name(::std::string* name)
    {
        if (name_ != &::google::protobuf::internal::kEmptyString)
        {
            delete name_;
        }
        if (name)
        {
            set_has_name();
            name_ = name;
        }
        else
        {
            clear_has_name();
            name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional string command = 3;
    inline bool JobOption::has_command() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void JobOption::set_has_command()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void JobOption::clear_has_command()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void JobOption::clear_command()
    {
        if (command_ != &::google::protobuf::internal::kEmptyString)
        {
            command_->clear();
        }
        clear_has_command();
    }
    inline const ::std::string& JobOption::command() const
    {
        return *command_;
    }
    inline void JobOption::set_command(const ::std::string& value)
    {
        set_has_command();
        if (command_ == &::google::protobuf::internal::kEmptyString)
        {
            command_ = new ::std::string;
        }
        command_->assign(value);
    }
    inline void JobOption::set_command(const char* value)
    {
        set_has_command();
        if (command_ == &::google::protobuf::internal::kEmptyString)
        {
            command_ = new ::std::string;
        }
        command_->assign(value);
    }
    inline void JobOption::set_command(const char* value, size_t size)
    {
        set_has_command();
        if (command_ == &::google::protobuf::internal::kEmptyString)
        {
            command_ = new ::std::string;
        }
        command_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* JobOption::mutable_command()
    {
        set_has_command();
        if (command_ == &::google::protobuf::internal::kEmptyString)
        {
            command_ = new ::std::string;
        }
        return command_;
    }
    inline ::std::string* JobOption::release_command()
    {
        clear_has_command();
        if (command_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = command_;
            command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void JobOption::set_allocated_command(::std::string* command)
    {
        if (command_ != &::google::protobuf::internal::kEmptyString)
        {
            delete command_;
        }
        if (command)
        {
            set_has_command();
            command_ = command;
        }
        else
        {
            clear_has_command();
            command_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// repeated string args = 4;
    inline int JobOption::args_size() const
    {
        return args_.size();
    }
    inline void JobOption::clear_args()
    {
        args_.Clear();
    }
    inline const ::std::string& JobOption::args(int index) const
    {
        return args_.Get(index);
    }
    inline ::std::string* JobOption::mutable_args(int index)
    {
        return args_.Mutable(index);
    }
    inline void JobOption::set_args(int index, const ::std::string& value)
    {
        args_.Mutable(index)->assign(value);
    }
    inline void JobOption::set_args(int index, const char* value)
    {
        args_.Mutable(index)->assign(value);
    }
    inline void JobOption::set_args(int index, const char* value, size_t size)
    {
        args_.Mutable(index)->assign(
            reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* JobOption::add_args()
    {
        return args_.Add();
    }
    inline void JobOption::add_args(const ::std::string& value)
    {
        args_.Add()->assign(value);
    }
    inline void JobOption::add_args(const char* value)
    {
        args_.Add()->assign(value);
    }
    inline void JobOption::add_args(const char* value, size_t size)
    {
        args_.Add()->assign(reinterpret_cast<const char*>(value), size);
    }
    inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
    JobOption::args() const
    {
        return args_;
    }
    inline ::google::protobuf::RepeatedPtrField< ::std::string>*
    JobOption::mutable_args()
    {
        return &args_;
    }

// repeated string environment = 5;
    inline int JobOption::environment_size() const
    {
        return environment_.size();
    }
    inline void JobOption::clear_environment()
    {
        environment_.Clear();
    }
    inline const ::std::string& JobOption::environment(int index) const
    {
        return environment_.Get(index);
    }
    inline ::std::string* JobOption::mutable_environment(int index)
    {
        return environment_.Mutable(index);
    }
    inline void JobOption::set_environment(int index, const ::std::string& value)
    {
        environment_.Mutable(index)->assign(value);
    }
    inline void JobOption::set_environment(int index, const char* value)
    {
        environment_.Mutable(index)->assign(value);
    }
    inline void JobOption::set_environment(int index, const char* value, size_t size)
    {
        environment_.Mutable(index)->assign(
            reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* JobOption::add_environment()
    {
        return environment_.Add();
    }
    inline void JobOption::add_environment(const ::std::string& value)
    {
        environment_.Add()->assign(value);
    }
    inline void JobOption::add_environment(const char* value)
    {
        environment_.Add()->assign(value);
    }
    inline void JobOption::add_environment(const char* value, size_t size)
    {
        environment_.Add()->assign(reinterpret_cast<const char*>(value), size);
    }
    inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
    JobOption::environment() const
    {
        return environment_;
    }
    inline ::google::protobuf::RepeatedPtrField< ::std::string>*
    JobOption::mutable_environment()
    {
        return &environment_;
    }

// optional string work_directory = 6;
    inline bool JobOption::has_work_directory() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void JobOption::set_has_work_directory()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void JobOption::clear_has_work_directory()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void JobOption::clear_work_directory()
    {
        if (work_directory_ != &::google::protobuf::internal::kEmptyString)
        {
            work_directory_->clear();
        }
        clear_has_work_directory();
    }
    inline const ::std::string& JobOption::work_directory() const
    {
        return *work_directory_;
    }
    inline void JobOption::set_work_directory(const ::std::string& value)
    {
        set_has_work_directory();
        if (work_directory_ == &::google::protobuf::internal::kEmptyString)
        {
            work_directory_ = new ::std::string;
        }
        work_directory_->assign(value);
    }
    inline void JobOption::set_work_directory(const char* value)
    {
        set_has_work_directory();
        if (work_directory_ == &::google::protobuf::internal::kEmptyString)
        {
            work_directory_ = new ::std::string;
        }
        work_directory_->assign(value);
    }
    inline void JobOption::set_work_directory(const char* value, size_t size)
    {
        set_has_work_directory();
        if (work_directory_ == &::google::protobuf::internal::kEmptyString)
        {
            work_directory_ = new ::std::string;
        }
        work_directory_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* JobOption::mutable_work_directory()
    {
        set_has_work_directory();
        if (work_directory_ == &::google::protobuf::internal::kEmptyString)
        {
            work_directory_ = new ::std::string;
        }
        return work_directory_;
    }
    inline ::std::string* JobOption::release_work_directory()
    {
        clear_has_work_directory();
        if (work_directory_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = work_directory_;
            work_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void JobOption::set_allocated_work_directory(::std::string* work_directory)
    {
        if (work_directory_ != &::google::protobuf::internal::kEmptyString)
        {
            delete work_directory_;
        }
        if (work_directory)
        {
            set_has_work_directory();
            work_directory_ = work_directory;
        }
        else
        {
            clear_has_work_directory();
            work_directory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional string runner_id = 7;
    inline bool JobOption::has_runner_id() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void JobOption::set_has_runner_id()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void JobOption::clear_has_runner_id()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void JobOption::clear_runner_id()
    {
        if (runner_id_ != &::google::protobuf::internal::kEmptyString)
        {
            runner_id_->clear();
        }
        clear_has_runner_id();
    }
    inline const ::std::string& JobOption::runner_id() const
    {
        return *runner_id_;
    }
    inline void JobOption::set_runner_id(const ::std::string& value)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(value);
    }
    inline void JobOption::set_runner_id(const char* value)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(value);
    }
    inline void JobOption::set_runner_id(const char* value, size_t size)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* JobOption::mutable_runner_id()
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        return runner_id_;
    }
    inline ::std::string* JobOption::release_runner_id()
    {
        clear_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = runner_id_;
            runner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void JobOption::set_allocated_runner_id(::std::string* runner_id)
    {
        if (runner_id_ != &::google::protobuf::internal::kEmptyString)
        {
            delete runner_id_;
        }
        if (runner_id)
        {
            set_has_runner_id();
            runner_id_ = runner_id;
        }
        else
        {
            clear_has_runner_id();
            runner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional int64 job_id = 8;
    inline bool JobOption::has_job_id() const
    {
        return (_has_bits_[0] & 0x00000080u) != 0;
    }
    inline void JobOption::set_has_job_id()
    {
        _has_bits_[0] |= 0x00000080u;
    }
    inline void JobOption::clear_has_job_id()
    {
        _has_bits_[0] &= ~0x00000080u;
    }
    inline void JobOption::clear_job_id()
    {
        job_id_ = GOOGLE_LONGLONG(0);
        clear_has_job_id();
    }
    inline ::google::protobuf::int64 JobOption::job_id() const
    {
        return job_id_;
    }
    inline void JobOption::set_job_id(::google::protobuf::int64 value)
    {
        set_has_job_id();
        job_id_ = value;
    }

// -------------------------------------------------------------------

// TaskOption

// optional string task_input = 1;
    inline bool TaskOption::has_task_input() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void TaskOption::set_has_task_input()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void TaskOption::clear_has_task_input()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void TaskOption::clear_task_input()
    {
        if (task_input_ != &::google::protobuf::internal::kEmptyString)
        {
            task_input_->clear();
        }
        clear_has_task_input();
    }
    inline const ::std::string& TaskOption::task_input() const
    {
        return *task_input_;
    }
    inline void TaskOption::set_task_input(const ::std::string& value)
    {
        set_has_task_input();
        if (task_input_ == &::google::protobuf::internal::kEmptyString)
        {
            task_input_ = new ::std::string;
        }
        task_input_->assign(value);
    }
    inline void TaskOption::set_task_input(const char* value)
    {
        set_has_task_input();
        if (task_input_ == &::google::protobuf::internal::kEmptyString)
        {
            task_input_ = new ::std::string;
        }
        task_input_->assign(value);
    }
    inline void TaskOption::set_task_input(const char* value, size_t size)
    {
        set_has_task_input();
        if (task_input_ == &::google::protobuf::internal::kEmptyString)
        {
            task_input_ = new ::std::string;
        }
        task_input_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* TaskOption::mutable_task_input()
    {
        set_has_task_input();
        if (task_input_ == &::google::protobuf::internal::kEmptyString)
        {
            task_input_ = new ::std::string;
        }
        return task_input_;
    }
    inline ::std::string* TaskOption::release_task_input()
    {
        clear_has_task_input();
        if (task_input_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = task_input_;
            task_input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void TaskOption::set_allocated_task_input(::std::string* task_input)
    {
        if (task_input_ != &::google::protobuf::internal::kEmptyString)
        {
            delete task_input_;
        }
        if (task_input)
        {
            set_has_task_input();
            task_input_ = task_input;
        }
        else
        {
            clear_has_task_input();
            task_input_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional string task_output = 2;
    inline bool TaskOption::has_task_output() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void TaskOption::set_has_task_output()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void TaskOption::clear_has_task_output()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void TaskOption::clear_task_output()
    {
        if (task_output_ != &::google::protobuf::internal::kEmptyString)
        {
            task_output_->clear();
        }
        clear_has_task_output();
    }
    inline const ::std::string& TaskOption::task_output() const
    {
        return *task_output_;
    }
    inline void TaskOption::set_task_output(const ::std::string& value)
    {
        set_has_task_output();
        if (task_output_ == &::google::protobuf::internal::kEmptyString)
        {
            task_output_ = new ::std::string;
        }
        task_output_->assign(value);
    }
    inline void TaskOption::set_task_output(const char* value)
    {
        set_has_task_output();
        if (task_output_ == &::google::protobuf::internal::kEmptyString)
        {
            task_output_ = new ::std::string;
        }
        task_output_->assign(value);
    }
    inline void TaskOption::set_task_output(const char* value, size_t size)
    {
        set_has_task_output();
        if (task_output_ == &::google::protobuf::internal::kEmptyString)
        {
            task_output_ = new ::std::string;
        }
        task_output_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* TaskOption::mutable_task_output()
    {
        set_has_task_output();
        if (task_output_ == &::google::protobuf::internal::kEmptyString)
        {
            task_output_ = new ::std::string;
        }
        return task_output_;
    }
    inline ::std::string* TaskOption::release_task_output()
    {
        clear_has_task_output();
        if (task_output_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = task_output_;
            task_output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void TaskOption::set_allocated_task_output(::std::string* task_output)
    {
        if (task_output_ != &::google::protobuf::internal::kEmptyString)
        {
            delete task_output_;
        }
        if (task_output)
        {
            set_has_task_output();
            task_output_ = task_output;
        }
        else
        {
            clear_has_task_output();
            task_output_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional int64 priority = 3;
    inline bool TaskOption::has_priority() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void TaskOption::set_has_priority()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void TaskOption::clear_has_priority()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void TaskOption::clear_priority()
    {
        priority_ = GOOGLE_LONGLONG(0);
        clear_has_priority();
    }
    inline ::google::protobuf::int64 TaskOption::priority() const
    {
        return priority_;
    }
    inline void TaskOption::set_priority(::google::protobuf::int64 value)
    {
        set_has_priority();
        priority_ = value;
    }

// optional string job_name = 4;
    inline bool TaskOption::has_job_name() const
    {
        return (_has_bits_[0] & 0x00000008u) != 0;
    }
    inline void TaskOption::set_has_job_name()
    {
        _has_bits_[0] |= 0x00000008u;
    }
    inline void TaskOption::clear_has_job_name()
    {
        _has_bits_[0] &= ~0x00000008u;
    }
    inline void TaskOption::clear_job_name()
    {
        if (job_name_ != &::google::protobuf::internal::kEmptyString)
        {
            job_name_->clear();
        }
        clear_has_job_name();
    }
    inline const ::std::string& TaskOption::job_name() const
    {
        return *job_name_;
    }
    inline void TaskOption::set_job_name(const ::std::string& value)
    {
        set_has_job_name();
        if (job_name_ == &::google::protobuf::internal::kEmptyString)
        {
            job_name_ = new ::std::string;
        }
        job_name_->assign(value);
    }
    inline void TaskOption::set_job_name(const char* value)
    {
        set_has_job_name();
        if (job_name_ == &::google::protobuf::internal::kEmptyString)
        {
            job_name_ = new ::std::string;
        }
        job_name_->assign(value);
    }
    inline void TaskOption::set_job_name(const char* value, size_t size)
    {
        set_has_job_name();
        if (job_name_ == &::google::protobuf::internal::kEmptyString)
        {
            job_name_ = new ::std::string;
        }
        job_name_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* TaskOption::mutable_job_name()
    {
        set_has_job_name();
        if (job_name_ == &::google::protobuf::internal::kEmptyString)
        {
            job_name_ = new ::std::string;
        }
        return job_name_;
    }
    inline ::std::string* TaskOption::release_job_name()
    {
        clear_has_job_name();
        if (job_name_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = job_name_;
            job_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void TaskOption::set_allocated_job_name(::std::string* job_name)
    {
        if (job_name_ != &::google::protobuf::internal::kEmptyString)
        {
            delete job_name_;
        }
        if (job_name)
        {
            set_has_job_name();
            job_name_ = job_name;
        }
        else
        {
            clear_has_job_name();
            job_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional string runner_id = 5;
    inline bool TaskOption::has_runner_id() const
    {
        return (_has_bits_[0] & 0x00000010u) != 0;
    }
    inline void TaskOption::set_has_runner_id()
    {
        _has_bits_[0] |= 0x00000010u;
    }
    inline void TaskOption::clear_has_runner_id()
    {
        _has_bits_[0] &= ~0x00000010u;
    }
    inline void TaskOption::clear_runner_id()
    {
        if (runner_id_ != &::google::protobuf::internal::kEmptyString)
        {
            runner_id_->clear();
        }
        clear_has_runner_id();
    }
    inline const ::std::string& TaskOption::runner_id() const
    {
        return *runner_id_;
    }
    inline void TaskOption::set_runner_id(const ::std::string& value)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(value);
    }
    inline void TaskOption::set_runner_id(const char* value)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(value);
    }
    inline void TaskOption::set_runner_id(const char* value, size_t size)
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        runner_id_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* TaskOption::mutable_runner_id()
    {
        set_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            runner_id_ = new ::std::string;
        }
        return runner_id_;
    }
    inline ::std::string* TaskOption::release_runner_id()
    {
        clear_has_runner_id();
        if (runner_id_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = runner_id_;
            runner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void TaskOption::set_allocated_runner_id(::std::string* runner_id)
    {
        if (runner_id_ != &::google::protobuf::internal::kEmptyString)
        {
            delete runner_id_;
        }
        if (runner_id)
        {
            set_has_runner_id();
            runner_id_ = runner_id;
        }
        else
        {
            clear_has_runner_id();
            runner_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// optional int64 job_id = 6;
    inline bool TaskOption::has_job_id() const
    {
        return (_has_bits_[0] & 0x00000020u) != 0;
    }
    inline void TaskOption::set_has_job_id()
    {
        _has_bits_[0] |= 0x00000020u;
    }
    inline void TaskOption::clear_has_job_id()
    {
        _has_bits_[0] &= ~0x00000020u;
    }
    inline void TaskOption::clear_job_id()
    {
        job_id_ = GOOGLE_LONGLONG(0);
        clear_has_job_id();
    }
    inline ::google::protobuf::int64 TaskOption::job_id() const
    {
        return job_id_;
    }
    inline void TaskOption::set_job_id(::google::protobuf::int64 value)
    {
        set_has_job_id();
        job_id_ = value;
    }

// optional int64 task_id = 7;
    inline bool TaskOption::has_task_id() const
    {
        return (_has_bits_[0] & 0x00000040u) != 0;
    }
    inline void TaskOption::set_has_task_id()
    {
        _has_bits_[0] |= 0x00000040u;
    }
    inline void TaskOption::clear_has_task_id()
    {
        _has_bits_[0] &= ~0x00000040u;
    }
    inline void TaskOption::clear_task_id()
    {
        task_id_ = GOOGLE_LONGLONG(0);
        clear_has_task_id();
    }
    inline ::google::protobuf::int64 TaskOption::task_id() const
    {
        return task_id_;
    }
    inline void TaskOption::set_task_id(::google::protobuf::int64 value)
    {
        set_has_task_id();
        task_id_ = value;
    }

// -------------------------------------------------------------------

// Exception

// optional string message = 1;
    inline bool Exception::has_message() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void Exception::set_has_message()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void Exception::clear_has_message()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void Exception::clear_message()
    {
        if (message_ != &::google::protobuf::internal::kEmptyString)
        {
            message_->clear();
        }
        clear_has_message();
    }
    inline const ::std::string& Exception::message() const
    {
        return *message_;
    }
    inline void Exception::set_message(const ::std::string& value)
    {
        set_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString)
        {
            message_ = new ::std::string;
        }
        message_->assign(value);
    }
    inline void Exception::set_message(const char* value)
    {
        set_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString)
        {
            message_ = new ::std::string;
        }
        message_->assign(value);
    }
    inline void Exception::set_message(const char* value, size_t size)
    {
        set_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString)
        {
            message_ = new ::std::string;
        }
        message_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* Exception::mutable_message()
    {
        set_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString)
        {
            message_ = new ::std::string;
        }
        return message_;
    }
    inline ::std::string* Exception::release_message()
    {
        clear_has_message();
        if (message_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = message_;
            message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void Exception::set_allocated_message(::std::string* message)
    {
        if (message_ != &::google::protobuf::internal::kEmptyString)
        {
            delete message_;
        }
        if (message)
        {
            set_has_message();
            message_ = message;
        }
        else
        {
            clear_has_message();
            message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// -------------------------------------------------------------------

// CommandHeader

// optional string context_id = 1;
    inline bool CommandHeader::has_context_id() const
    {
        return (_has_bits_[0] & 0x00000001u) != 0;
    }
    inline void CommandHeader::set_has_context_id()
    {
        _has_bits_[0] |= 0x00000001u;
    }
    inline void CommandHeader::clear_has_context_id()
    {
        _has_bits_[0] &= ~0x00000001u;
    }
    inline void CommandHeader::clear_context_id()
    {
        if (context_id_ != &::google::protobuf::internal::kEmptyString)
        {
            context_id_->clear();
        }
        clear_has_context_id();
    }
    inline const ::std::string& CommandHeader::context_id() const
    {
        return *context_id_;
    }
    inline void CommandHeader::set_context_id(const ::std::string& value)
    {
        set_has_context_id();
        if (context_id_ == &::google::protobuf::internal::kEmptyString)
        {
            context_id_ = new ::std::string;
        }
        context_id_->assign(value);
    }
    inline void CommandHeader::set_context_id(const char* value)
    {
        set_has_context_id();
        if (context_id_ == &::google::protobuf::internal::kEmptyString)
        {
            context_id_ = new ::std::string;
        }
        context_id_->assign(value);
    }
    inline void CommandHeader::set_context_id(const char* value, size_t size)
    {
        set_has_context_id();
        if (context_id_ == &::google::protobuf::internal::kEmptyString)
        {
            context_id_ = new ::std::string;
        }
        context_id_->assign(reinterpret_cast<const char*>(value), size);
    }
    inline ::std::string* CommandHeader::mutable_context_id()
    {
        set_has_context_id();
        if (context_id_ == &::google::protobuf::internal::kEmptyString)
        {
            context_id_ = new ::std::string;
        }
        return context_id_;
    }
    inline ::std::string* CommandHeader::release_context_id()
    {
        clear_has_context_id();
        if (context_id_ == &::google::protobuf::internal::kEmptyString)
        {
            return NULL;
        }
        else
        {
            ::std::string* temp = context_id_;
            context_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
            return temp;
        }
    }
    inline void CommandHeader::set_allocated_context_id(::std::string* context_id)
    {
        if (context_id_ != &::google::protobuf::internal::kEmptyString)
        {
            delete context_id_;
        }
        if (context_id)
        {
            set_has_context_id();
            context_id_ = context_id;
        }
        else
        {
            clear_has_context_id();
            context_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
        }
    }

// required int32 type = 2;
    inline bool CommandHeader::has_type() const
    {
        return (_has_bits_[0] & 0x00000002u) != 0;
    }
    inline void CommandHeader::set_has_type()
    {
        _has_bits_[0] |= 0x00000002u;
    }
    inline void CommandHeader::clear_has_type()
    {
        _has_bits_[0] &= ~0x00000002u;
    }
    inline void CommandHeader::clear_type()
    {
        type_ = 0;
        clear_has_type();
    }
    inline ::google::protobuf::int32 CommandHeader::type() const
    {
        return type_;
    }
    inline void CommandHeader::set_type(::google::protobuf::int32 value)
    {
        set_has_type();
        type_ = value;
    }

// optional int64 data_size = 3;
    inline bool CommandHeader::has_data_size() const
    {
        return (_has_bits_[0] & 0x00000004u) != 0;
    }
    inline void CommandHeader::set_has_data_size()
    {
        _has_bits_[0] |= 0x00000004u;
    }
    inline void CommandHeader::clear_has_data_size()
    {
        _has_bits_[0] &= ~0x00000004u;
    }
    inline void CommandHeader::clear_data_size()
    {
        data_size_ = GOOGLE_LONGLONG(0);
        clear_has_data_size();
    }
    inline ::google::protobuf::int64 CommandHeader::data_size() const
    {
        return data_size_;
    }
    inline void CommandHeader::set_data_size(::google::protobuf::int64 value)
    {
        set_has_data_size();
        data_size_ = value;
    }


// @@protoc_insertion_point(namespace_scope)

}  // namespace ogl

#ifndef SWIG
namespace google
{
    namespace protobuf
    {


    }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_marshal_2eproto__INCLUDED
